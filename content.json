{"meta":{"title":"1024-HOPE","subtitle":null,"description":null,"author":"zhangweilong","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"APT","slug":"apt","date":"2019-01-10T02:04:33.799Z","updated":"2019-01-10T13:08:19.128Z","comments":true,"path":"2019/01/10/apt/","link":"","permalink":"http://yoursite.com/2019/01/10/apt/","excerpt":"","text":"APT友情链接： https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/ https://github.com/Gavin-ZYX/APTTest.git aptAPT(Annotation Processing Tool)是一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，根据注释自动生成代码。Annotation处理器在出来Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件（文件具体内容由Annotation处理器的编写者决定），APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。 annotationProcessorannotationProcessor是APT工具中的一种，他是google开发的内置框架，不需要引入，可以直接在build.gradle文件中使用 android-aptandroid-apt是由一位开发者自己开发的apt框架，源代码托管在这里，随着Android Gradle 插件 2.2 版本的发布，Android Gradle 插件提供了名为 annotationProcessor 的功能来完全代替 android-apt ，自此android-apt 作者在官网发表声明最新的Android Gradle插件现在已经支持annotationProcessor，并警告和或阻止android-apt ，并推荐大家使用 Android 官方插件annotationProcessor。 Demomodule123apt-annotation (java-library)apt-processor (java-library)apt-library (com.android.library) apt-annotation 注解类BindView(编译时注解) 12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.FIELD)public @interface BindView &#123; int value();&#125; build.gradle 12345678apply plugin: &apos;java-library&apos;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])&#125;sourceCompatibility = &quot;1.7&quot;targetCompatibility = &quot;1.7&quot; apt-processor build.gradle 1234567891011apply plugin: &apos;java-library&apos;dependencies &#123; implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) implementation &apos;com.google.auto.service:auto-service:1.0-rc2&apos; implementation &apos;com.squareup:javapoet:1.10.0&apos; implementation project(&apos;:apt-annotation&apos;)&#125;sourceCompatibility = &quot;1.7&quot;targetCompatibility = &quot;1.7&quot; AbstractProcessor 1234567891011121314151617181920212223@SupportedAnnotationTypes(&#123;&quot;com.example.gavin.apt_annotation.BindView&quot;&#125;)@AutoService(Processor.class)public class TestProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; return super.getSupportedAnnotationTypes(); &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return super.getSupportedSourceVersion(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; return false; &#125;&#125; 添加自己需要处理的注解，可以通过两种方式：getSupportedAnnotationTypes()或者直接用注解@SupportedAnnotationTypes(“全路径”) process方法 123456789101112131415161718192021222324252627282930313233mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;processing...&quot;); // 1.会执行多次，所以要先clear mProxyMap.clear(); // 2.得到所有的注解并收集到map中 Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(BindView.class); for (Element element : elements) &#123; VariableElement variableElement = (VariableElement) element; TypeElement classElement = (TypeElement) variableElement.getEnclosingElement(); String fullClassName = classElement.getQualifiedName().toString(); //elements的信息保存到mProxyMap中 ClassCreatorProxy proxy = mProxyMap.get(fullClassName); if (proxy == null) &#123; proxy = new ClassCreatorProxy(mElementUtils, classElement); mProxyMap.put(fullClassName, proxy); &#125; BindView bindAnnotation = variableElement.getAnnotation(BindView.class); int id = bindAnnotation.value(); proxy.putElement(id, variableElement); &#125; // 3.通过遍历mProxyMap，创建java文件 通过javapoet生成 for (String key : mProxyMap.keySet()) &#123; ClassCreatorProxy proxyInfo = mProxyMap.get(key); JavaFile javaFile = JavaFile.builder(proxyInfo.getPackageName(), proxyInfo.generateJavaCode2()).build(); try &#123; // 生成文件 javaFile.writeTo(mFiler); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;process finish ...&quot;); return true;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-09T13:57:38.096Z","updated":"2019-01-10T03:27:27.309Z","comments":true,"path":"2019/01/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 直接下面一句话：1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d","categories":[],"tags":[]}]}